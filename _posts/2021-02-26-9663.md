---

title: "9663"
excerpt: "N-Queen"

categories:

 - 백준 

---

### 문제

---

N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.

N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오.





### 입력

---

첫째 줄에 N이 주어진다. (1 ≤ N < 15)




### 출력

---

첫째 줄에 퀸 N개를 서로 공격할 수 없게 놓는 경우의 수를 출력한다.





이게 무슨소리일까

일단 0,0으로 시작해서 한 판을 다 돌면서 확인해본 결과, dfs과정을 거치고 나면 한판의 답은 잘 나온다



그러면 이게 모든 점에서 시작해서 다 돌면서 모든 점에서의 경우의 수를 구하라? 그건가?









### 예제 입력

---

```
8
```



### 예제 출력

---

```
92
```







### 풀이

---

```java
import java.io.*;
import java.util.*;

public class Main{
    static boolean visited[][];
    static int count=1;
    static int N;
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        N = Integer.parseInt(br.readLine());

        //자바에서 boolean 배열을 생성하는 경우에 false값을 초기화되어있다!!


//        for (int i = 0; i < N; i++) {
//            for (int j = 0; j < N; j++) {
//                visited = new boolean[N][N];
//                dfs(visited, i, j, 0);
//            }
//        }

        visited = new boolean[N][N];
        dfs(visited, 0, 0, 0);
        System.out.println(count);
    }

    public static void dfs(boolean[][] arr, int x, int y, int depth){
        if(depth==arr.length){
            for (int i = 0; i < arr.length; i++) {
                for (int j = 0; j < arr.length; j++) {
                    if(visited[i][j] == true)
                        count++;
                }
            }
            return;
        }

        //일단 갈 수 없는 곳을 체크해줘야 한다
        //x축을 기준으로 진행한다

        //만약 현재 자리가 false상태로, 아무거나 둘 수 있는 상태일때,
        if(visited[x][y] == false){
            //현재위치에서의 y축으로쭉, 대각선으로쭉, x축으로쭉 못가게 true해줌
            for (int j = 0; j < N; j++) {
                visited[x][j] = true;
                visited[j][j] = true;
                visited[j][y] = true;
            }
            //이제는 가능한 장소를 찾아서 가능한 곳에서 새로운 dfs를 진행해줘야한다

            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if(visited[i][j] == false){
                        count++;
                        dfs(arr, i, j, depth+1);
                    }
                }

            }

        }


    }
}
```









---

[백준](https://www.acmicpc.net/problem/9663)



